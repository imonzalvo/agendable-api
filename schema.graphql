### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String
  user: User
}

type AvailabilityItem {
  day: Day!
  employee: Employee!
  from: String!
  id: String!
  to: String!
}

input AvailabilityItemListRelationFilter {
  every: AvailabilityItemWhereInput
  none: AvailabilityItemWhereInput
  some: AvailabilityItemWhereInput
}

input AvailabilityItemWhereInput {
  AND: [AvailabilityItemWhereInput!]
  day: EnumDayFilter
  employee: EmployeeWhereInput
  employeeId: StringFilter
  from: StringFilter
  id: StringFilter
  NOT: [AvailabilityItemWhereInput!]
  OR: [AvailabilityItemWhereInput!]
  to: StringFilter
}

input AvailabilityItemWhereUniqueInput {
  id: String
}

type Booking {
  branch: Branch!
  client: User
  clientEmail: String
  clientFamilyName: String
  clientName: String
  clientPhone: String
  employee: Employee!
  end: String!
  id: String!
  services(after: ServiceWhereUniqueInput, before: ServiceWhereUniqueInput, first: Int, last: Int): [Service!]!
  start: String!
  status: BookingStatus!
}

input BookingListRelationFilter {
  every: BookingWhereInput
  none: BookingWhereInput
  some: BookingWhereInput
}

enum BookingStatus {
  CANCELLED
  COMPLETED
  CONFIRMED
  PENDING
}

input BookingsWhereInputType {
  from: String!
  to: String!
}

input BookingWhereInput {
  AND: [BookingWhereInput!]
  branch: BranchWhereInput
  branchId: StringFilter
  client: UserWhereInput
  clientEmail: StringNullableFilter
  clientFamilyName: StringNullableFilter
  clientId: StringNullableFilter
  clientName: StringNullableFilter
  clientPhone: StringNullableFilter
  employee: EmployeeWhereInput
  employeeId: StringFilter
  end: StringFilter
  id: StringFilter
  NOT: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  services: ServiceListRelationFilter
  start: StringFilter
  status: EnumBookingStatusFilter
}

input BookingWhereUniqueInput {
  id: String
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Branch {
  address: String!
  bookings(after: BookingWhereUniqueInput, before: BookingWhereUniqueInput, first: Int, last: Int): [Booking!]!
  business: Business!
  categories(after: CategoryWhereUniqueInput, before: CategoryWhereUniqueInput, first: Int, last: Int): [Category!]!
  description: String!
  email: String!
  employees(after: EmployeeWhereUniqueInput, before: EmployeeWhereUniqueInput, first: Int, last: Int): [Employee!]!
  id: String!
  image: String
  name: String!
  phone: String!
  services(after: ServiceWhereUniqueInput, before: ServiceWhereUniqueInput, first: Int, last: Int): [Service!]!
}

input BranchListRelationFilter {
  every: BranchWhereInput
  none: BranchWhereInput
  some: BranchWhereInput
}

input BranchWhereInput {
  address: StringFilter
  AND: [BranchWhereInput!]
  bookings: BookingListRelationFilter
  business: BusinessWhereInput
  businessId: StringFilter
  categories: CategoryListRelationFilter
  description: StringFilter
  email: StringFilter
  employees: EmployeeListRelationFilter
  id: StringFilter
  image: StringNullableFilter
  name: StringFilter
  NOT: [BranchWhereInput!]
  OR: [BranchWhereInput!]
  phone: StringFilter
  services: ServiceListRelationFilter
}

input BranchWhereUniqueInput {
  id: String
}

type Business {
  branches(after: BranchWhereUniqueInput, before: BranchWhereUniqueInput, first: Int, last: Int): [Branch!]!
  categories(after: CategoryWhereUniqueInput, before: CategoryWhereUniqueInput, first: Int, last: Int): [Category!]!
  email: String!
  facebookUrl: String
  handle: String!
  id: String!
  instagramUrl: String
  landing: LandingInfo
  name: String!
  owner: User!
  phone: String!
  services(after: ServiceWhereUniqueInput, before: ServiceWhereUniqueInput, first: Int, last: Int): [Service!]!
  website: String
}

type BusinessImage {
  id: String!
  landingInfo: LandingInfo
  url: String!
}

input BusinessImageListRelationFilter {
  every: BusinessImageWhereInput
  none: BusinessImageWhereInput
  some: BusinessImageWhereInput
}

input BusinessImageWhereInput {
  AND: [BusinessImageWhereInput!]
  id: StringFilter
  landingInfo: LandingInfoWhereInput
  landingInfoId: StringNullableFilter
  NOT: [BusinessImageWhereInput!]
  OR: [BusinessImageWhereInput!]
  url: StringFilter
}

input BusinessImageWhereUniqueInput {
  id: String
}

input BusinessWhereInput {
  AND: [BusinessWhereInput!]
  branches: BranchListRelationFilter
  categories: CategoryListRelationFilter
  email: StringFilter
  facebookUrl: StringNullableFilter
  handle: StringFilter
  id: StringFilter
  instagramUrl: StringNullableFilter
  landing: LandingInfoWhereInput
  name: StringFilter
  NOT: [BusinessWhereInput!]
  OR: [BusinessWhereInput!]
  owner: UserWhereInput
  ownerId: StringFilter
  phone: StringFilter
  services: ServiceListRelationFilter
  website: StringNullableFilter
}

type Category {
  branches(after: BranchWhereUniqueInput, before: BranchWhereUniqueInput, first: Int, last: Int): [Branch!]!
  Business: Business
  id: String!
  name: String!
  services(after: ServiceWhereUniqueInput, before: ServiceWhereUniqueInput, first: Int, last: Int): [Service!]!
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  branches: BranchListRelationFilter
  Business: BusinessWhereInput
  businessId: StringNullableFilter
  id: StringFilter
  name: StringFilter
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  services: ServiceListRelationFilter
}

input CategoryWhereUniqueInput {
  id: String
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

enum Day {
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
}

type Employee {
  availability(after: AvailabilityItemWhereUniqueInput, before: AvailabilityItemWhereUniqueInput, first: Int, last: Int): [AvailabilityItem!]!
  availableTime(date: String, duration: Int): [EmployeeAvailableTime]
  bookings(after: BookingWhereUniqueInput, before: BookingWhereUniqueInput, first: Int, last: Int): [Booking!]!
  branches(after: BranchWhereUniqueInput, before: BranchWhereUniqueInput, first: Int, last: Int): [Branch!]!
  familyName: String!
  givenName: String!
  id: String!
  phone: String!
  services(after: ServiceWhereUniqueInput, before: ServiceWhereUniqueInput, first: Int, last: Int): [Service!]!
  user: User
  vacations(after: VacationsItemWhereUniqueInput, before: VacationsItemWhereUniqueInput, first: Int, last: Int): [VacationsItem!]!
}

type EmployeeAvailableTime {
  from: String
  to: String
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  none: EmployeeWhereInput
  some: EmployeeWhereInput
}

type EmployeesAvailableTime {
  availability: [EmployeeAvailableTime]
  id: String
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  availability: AvailabilityItemListRelationFilter
  bookings: BookingListRelationFilter
  branches: BranchListRelationFilter
  familyName: StringFilter
  givenName: StringFilter
  id: StringFilter
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  phone: StringFilter
  services: ServiceListRelationFilter
  user: UserWhereInput
  userId: StringNullableFilter
  vacations: VacationsItemListRelationFilter
}

input EmployeeWhereUniqueInput {
  id: String
}

input EnumBookingStatusFilter {
  equals: BookingStatus
  in: [BookingStatus!]
  not: NestedEnumBookingStatusFilter
  notIn: [BookingStatus!]
}

input EnumDayFilter {
  equals: Day
  in: [Day!]
  not: NestedEnumDayFilter
  notIn: [Day!]
}

input EnumUserTypeFilter {
  equals: UserType
  in: [UserType!]
  not: NestedEnumUserTypeFilter
  notIn: [UserType!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type LandingInfo {
  business: Business
  cta: String
  description: String!
  displayName: String!
  id: String!
  images(after: BusinessImageWhereUniqueInput, before: BusinessImageWhereUniqueInput, first: Int, last: Int): [BusinessImage!]!
}

input LandingInfoInputType {
  businessId: String!
  cta: String
  description: String!
  displayName: String!
  facebookUrl: String
  imagesUrl: [String!]
  instagramUrl: String
  website: String
}

input LandingInfoWhereInput {
  AND: [LandingInfoWhereInput!]
  business: BusinessWhereInput
  businessId: StringNullableFilter
  cta: StringNullableFilter
  description: StringFilter
  displayName: StringFilter
  id: StringFilter
  images: BusinessImageListRelationFilter
  NOT: [LandingInfoWhereInput!]
  OR: [LandingInfoWhereInput!]
}

type Mutation {
  addCategoryToBusiness(businessId: ID, categories: [String]): Business
  addImagesLandingInfo(imagesUrl: [String], landingInfoId: ID): LandingInfo
  confirmUser(email: String, verifyToken: String): AuthPayload
  createAvailabilityItem(day: String!, employeeId: String!, from: String!, to: String!): AvailabilityItem
  createBooking(branchId: String!, clientEmail: String, clientFamilyName: String, clientId: String, clientName: String, clientPhone: String, employeeId: String!, end: String!, servicesId: [String!]!, start: String!, status: String): Booking
  createBranch(address: String!, description: String!, email: String!, image: String, name: String!, phone: String!): Branch
  createBusiness(categories: [String], email: String!, facebookUrl: String, handle: String!, instagramUrl: String, name: String!, phone: String!, website: String): Business
  createDraft(content: String, title: String): Post
  createEmployee(branchesId: [String], familyName: String!, givenName: String!, phone: String!, servicesId: [String], userId: String): Employee
  createLandingInfo(businessId: ID!, cta: String, description: String!, displayName: String!, imagesUrl: [String!]!): LandingInfo
  createService(branchesId: [String!]!, categoryId: ID!, currency: String!, description: String!, duration: Int!, name: String!, price: Float!): Service
  createVacationsItem(employeeId: String!, from: String!, to: String!): VacationsItem
  deleteBooking(id: ID!): Booking
  deleteBranch(id: ID!): Branch
  deleteLandingInfo(id: ID): LandingInfo
  deletePost(id: ID): Post
  login(email: String, password: String, phone: String): AuthPayload
  publish(id: ID): Post
  signup(email: String, familyName: String, givenName: String, name: String, password: String, phone: String, userName: String, userType: String): AuthPayload
  updateAvailabilityItem(day: String, from: String, id: ID!, to: String): AvailabilityItem
  updateBooking(branchId: String, clientEmail: String, clientFamilyName: String, clientId: String, clientName: String, clientPhone: String, employeeId: String, end: String, id: ID!, servicesId: [String], start: String, status: String): Booking
  updateBranch(address: String, categoriesId: [String], description: String, email: String, id: ID!, image: String, name: String, phone: String, servicesId: [String]): Branch
  updateBusiness(email: String, facebookUrl: String, handle: String, id: ID!, instagramUrl: String, name: String, phone: String, website: String): Business
  updateEmployee(branchesId: [String], familyName: String, givenName: String, id: ID!, phone: String, servicesId: [String], userId: String): Employee
  updateLandingInfo(cta: String, description: String, displayName: String, id: ID!): LandingInfo
  updateNotification(id: ID!, seen: Boolean!): Notification
  updateService(categoryId: ID, currency: String, description: String, duration: Int, id: String!, name: String, price: Float): Service
  updateVacationsItem(employeeId: String, from: String, id: ID!, to: String): VacationsItem
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumBookingStatusFilter {
  equals: BookingStatus
  in: [BookingStatus!]
  not: NestedEnumBookingStatusFilter
  notIn: [BookingStatus!]
}

input NestedEnumDayFilter {
  equals: Day
  in: [Day!]
  not: NestedEnumDayFilter
  notIn: [Day!]
}

input NestedEnumUserTypeFilter {
  equals: UserType
  in: [UserType!]
  not: NestedEnumUserTypeFilter
  notIn: [UserType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Notification {
  createdAt: DateTime!
  id: String!
  seen: Boolean!
  title: String!
  type: String!
  user: User!
}

input NotificationListRelationFilter {
  every: NotificationWhereInput
  none: NotificationWhereInput
  some: NotificationWhereInput
}

input NotificationWhereInput {
  AND: [NotificationWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  resourceId: StringFilter
  seen: BoolFilter
  title: StringFilter
  type: StringFilter
  user: UserWhereInput
  userId: StringFilter
}

type Post {
  author: User
  content: String
  id: String!
  published: Boolean!
  title: String!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: UserWhereInput
  authorId: StringNullableFilter
  content: StringNullableFilter
  id: StringFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  published: BoolFilter
  title: StringFilter
}

input PostWhereUniqueInput {
  id: String
}

type Query {
  emailAvailability(email: String): Boolean
  feed: [Post]
  filterPosts(searchString: String): [Post]
  getAvailabilityItem(id: ID): AvailabilityItem
  getAvailabilityItems: [AvailabilityItem]
  getBooking(id: String): Booking
  getBookings(where: BookingsWhereInputType): [Booking]
  getBookingsByBranch(branchId: String): [Booking]
  getBookingsByBusiness(id: String): [Booking]
  getBookingsByDate(branchId: String, employeeId: String, endDate: String!, startDate: String!): [Booking]
  getBranch(id: String): Branch
  getBranches: [Branch]
  getBusiness(id: String): Business
  getBusinessByHandle(handle: String): Business
  getBusinessEmployees(id: ID): [Employee]
  getBusinesses: [Business]
  getEmployee(id: String): Employee
  getEmployeeAvailableDays(employeeId: ID, endDate: String, startDate: String): [String]
  getEmployeeAvailableTime(date: String, duration: Int, id: ID): [EmployeeAvailableTime]
  getEmployees: [Employee]
  getEmployeesAvailableTime(date: String, duration: Int, ids: [ID]): [EmployeesAvailableTime]
  getService(id: String): Service
  getServices: [Service]
  getVacationsItem(id: ID): VacationsItem
  getVacationsItems: [VacationsItem]
  me: User
  post(id: ID): Post
}

enum QueryMode {
  default
  insensitive
}

type Service {
  bookings(after: BookingWhereUniqueInput, before: BookingWhereUniqueInput, first: Int, last: Int): [Booking!]!
  branches(after: BranchWhereUniqueInput, before: BranchWhereUniqueInput, first: Int, last: Int): [Branch!]!
  category: Category
  currency: String!
  description: String!
  duration: Int!
  employees(after: EmployeeWhereUniqueInput, before: EmployeeWhereUniqueInput, first: Int, last: Int): [Employee!]!
  id: String!
  name: String!
  price: Float!
}

input ServiceListRelationFilter {
  every: ServiceWhereInput
  none: ServiceWhereInput
  some: ServiceWhereInput
}

input ServiceWhereInput {
  AND: [ServiceWhereInput!]
  bookings: BookingListRelationFilter
  branches: BranchListRelationFilter
  Business: BusinessWhereInput
  businessId: StringNullableFilter
  category: CategoryWhereInput
  categoryId: StringNullableFilter
  currency: StringFilter
  description: StringFilter
  duration: IntFilter
  employees: EmployeeListRelationFilter
  id: StringFilter
  name: StringFilter
  NOT: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  price: FloatFilter
}

input ServiceWhereUniqueInput {
  id: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  deletedBooking(branchId: String): Booking
  newBooking(branchId: String): Booking
  updatedBooking(branchId: String): Booking
}

type User {
  bookings: [Booking!]!
  business: Business
  email: String!
  familyName: String!
  givenName: String!
  id: String!
  name: String
  notifications(after: String, take: Int): [Notification]
  phone: String
  posts(after: PostWhereUniqueInput, before: PostWhereUniqueInput, first: Int, last: Int, where: PostWhereInput): [Post!]!
  userType: UserType!
  verifyToken: String!
}

enum UserType {
  ADMIN
  GUEST
  USER
}

input UserWhereInput {
  AND: [UserWhereInput!]
  bookings: BookingListRelationFilter
  business: BusinessWhereInput
  email: StringFilter
  Employee: EmployeeListRelationFilter
  familyName: StringFilter
  givenName: StringFilter
  id: StringFilter
  name: StringNullableFilter
  NOT: [UserWhereInput!]
  notifications: NotificationListRelationFilter
  OR: [UserWhereInput!]
  password: StringFilter
  phone: StringNullableFilter
  posts: PostListRelationFilter
  userName: StringFilter
  userType: EnumUserTypeFilter
  verifyToken: StringFilter
}

type VacationsItem {
  employee: Employee!
  from: String!
  id: String!
  to: String!
}

input VacationsItemListRelationFilter {
  every: VacationsItemWhereInput
  none: VacationsItemWhereInput
  some: VacationsItemWhereInput
}

input VacationsItemWhereInput {
  AND: [VacationsItemWhereInput!]
  employee: EmployeeWhereInput
  employeeId: StringFilter
  from: StringFilter
  id: StringFilter
  NOT: [VacationsItemWhereInput!]
  OR: [VacationsItemWhereInput!]
  to: StringFilter
}

input VacationsItemWhereUniqueInput {
  id: String
}
